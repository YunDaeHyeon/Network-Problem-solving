<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>네트워크 퀴즈</title>
  <style>
    body {
      background-color: #e0e0e0;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }
    .notice {
      font-size: 0.85rem;
      color: #555;
      margin-bottom: 10px;
      text-align: center;
    }
    .quiz-box {
      text-align: center;
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      width: 100%;
      max-width: 600px;
      position: relative;
    }
    #question {
      font-size: 1.2rem;
      margin-bottom: 20px;
    }
    input[type="text"] {
      width: 90%;
      padding: 10px;
      font-size: 1rem;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
    #feedback {
      margin: 10px 0;
      font-weight: bold;
    }
    #summary {
      margin-top: 20px;
    }
    .nav-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: center;
    }
    .nav-buttons button {
      margin: 0 10px;
      padding: 8px 14px;
      font-size: 0.9rem;
      cursor: pointer;
    }
    @media (max-width: 768px) {
      .quiz-box {
        padding: 20px;
      }
      input[type="text"] {
        font-size: 1rem;
      }
      #question {
        font-size: 1.1rem;
      }
    }
    @media (max-width: 480px) {
      .quiz-box {
        padding: 15px;
      }
      input[type="text"] {
        font-size: 0.95rem;
      }
      #question {
        font-size: 1rem;
      }
      .nav-buttons button {
        font-size: 0.85rem;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <div class="notice">※ 최신 문제 업데이트 시간 : 4월 24일 오전 2시 11분 ※</div>
  <div class="notice">※ 2025년 4월 23일 기준 문제 수 : 68개 ※</div>
  <div class="notice">※ 모든 문자열을 완벽하게 입력해야 정답처리되니 오답 떠도 그냥 넘어가세요... ※</div>
  <div class="notice">※ 답 입력 후 엔터 눌러야 다음으로 넘어가요.. ※</div>
  <div class="notice">※ 해당 사이트는 웹브라우저 최적화입니다.. 휴대폰은 알아서..? ※</div>
  <div class="notice">※ 문제 도움 준 사람(ㄱㅅ) : ㅊㅈㅌ ※</div>
  <div class="quiz-box">
    <div id="question"></div>
    <input type="text" id="answerInput" placeholder="정답을 입력하세요" autofocus />
    <div id="feedback"></div>
    <div id="summary"></div>
    <div class="nav-buttons">
      <button onclick="prevQuestion()">이전 문제</button>
      <button onclick="nextQuestion()">다음 문제</button>
    </div>
  </div>

  <script>
    const quizData = [
      { q: "사설 IP를 공인 IP로 변경하는 것은?", a: "NAT" },
      { q: "ping 명령어가 실행 될 때 사용되는 프로토콜은?", a: "ICMP" },
      { q: "윈도우에서 IP 주소를 확인하는 명령어", a: "ipconfig" },
      { q: "윈도우에서 MAC 주소를 확인하는 명령어", a: "ipconfig /all" },
      { q: "리눅스에서 MAC과 IP 주소를 확인하는 명령어", a: "ip address show" },
      { q: "TCP/IP 각 계층에서 처리하는 정보 단위(PDU)의 명칭(상위계층부터)", a: "데이터, 세그먼트, 패킷, 프레임" },
      { q: "MAC, IP, Port의 주소 길이(크기)는?", a: "MAC : 6바이트 / IP : 4바이트 / Port : 2바이트" },
      { q: "20, 21 포트가 의미하는 프로토콜은?", a: "FTP" },
      { q: "22 포트가 의미하는 프로토콜은?", a: "SSH" },
      { q: "23 포트가 의미하는 프로토콜은?", a: "TELNET" },
      { q: "25 포트가 의미하는 프로토콜은?", a: "SMTP" },
      { q: "80 포트가 의미하는 프로토콜은?", a: "HTTP" },
      { q: "443 포트가 의미하는 프로토콜은?", a: "HTTPS" },
      { q: "53 포트가 의미하는 프로토콜은?", a: "DNS" },
      { q: "ISO/OSI 7계층 L1~L7 한글/영어 순서", a: "Physical/물리, Data Link/데이터링크, Network/네트워크, Transport/전송, Session/세션, Presentation/표현, Application/응용" },
      { q: "각 계층에서 처리하는 정보 단위(PDU)에 포함된 주소", a: "L4: 포트 번호 / L3: IP 주소 / L2: MAC 주소" },
      { q: "TCP/IP 전송계층에 속한 대표적인 2가지 프로토콜", a: "TCP와 UDP" },
      { q: "TCP 연결 설정 절차를 무엇이라고 하는가?", a: "3-way handshaking (SYN -> SYN/ACK -> ACK)" },
      { q: "3-way handshaking의 3단계를 순서대로 적으시오.", a: "SYN -> SYN/ACK -> ACK" },
      { q: "Switch가 저장하는 정보 2가지", a: "Port와 MAC" },
      { q: "ARP 테이블이 저장하는 정보 2가지", a: "IP와 MAC" },
      { q: "ARP 테이블을 출력하는 명령", a: "arp -a" },
      { q: "ARP 테이블을 삭제하는 명령", a: "arp -d *" },
      { q: "주어진 IP에 해당하는 MAC을 가져오는 프로토콜", a: "ARP" },
      { q: "VMware에서 호스트와 같은 네트워크 대역을 쓰는 모드", a: "Bridged" },
      { q: "VMware에서 호스트와 다른 네트워크 대역을 쓰는 모드", a: "NAT" },
      { q: "IP가 없는 컴퓨터가 IP를 동적으로 받는 프로토콜", a: "DHCP" },
      { q: "도메인 ↔ IP 주소 변환에 사용하는 프로토콜", a: "DNS" },
      { q: "8.8.8.8에 해당하는 도메인 이름을 가져오는 명령어", a: "nslookup 8.8.8.8" },
      { q: "라우터 내 동일 네트워크에서 출발지, 목적지 컴퓨터를 유일하게 식별하는 단위는?", a: "MAC 주소" },
      { q: "인터넷 상에서 출발지, 목적지 컴퓨터를 유일하게 식별하는 단위는?", a: "IP 주소" },
      { q: "한 컴퓨터 내에서 응용 프로그램을 유일하게 식별하는 단위는?", a: "Port 번호" },
      { q: "인터넷 상에서 유일한 연결을 식별하는 단위는?", a: "Socket(소켓)" },
      { q: "널리 사용되는 네트워크 패킷 분석 도구", a: "Wireshark" },
      { q: "도메인 이름에 대한 IP 주소를 찾는 명령어는?", a: "nslookup" },
      { q: "PC에 저장된 DNS 캐시를 출력하는 명령어는?", a: "ipconfig /displaydns" },
      { q: "PC에 저장된 DNS 캐시를 삭제하는 명령어는?", a: "ipconfig /flushdns" },
      { q: "브로드캐스트 프레임 목적지 MAC 주소는?", a: "FF:FF:FF:FF:FF:FF" },
      { q: "스위치가 브로드캐스트 프레임을 전송하는 동작은?", a: "Flooding" },
      { q: "목적지 MAC을 모르면 다른 네트워크로 프레임을 보내는 곳은?", a: "디폴트 게이트웨이(Default Gateway)" },
      { q: "스위치가 목적지 MAC을 알고 있을 때 수행하는 동작은?", a: "스위칭(Switching)" },
      { q: "프레임 꼬리에 붙는 데이터는?", a: "프레임 트레일러(FCS)" },
      { q: "스위치가 수신 프레임을 임시 저장하는 곳은?", a: "내부 임시 기억장소(버퍼, Buffer)" },
      { q: "네트워크 연결의 3단계는?", a: "물리, 논리, 응용" },
      { q: "191.23.124.4 IP 주소의 클래스와 기본 서브넷마스크 값은?", a: "B클래스, 255.255.0.0" },
      { q: "A클래스의 IP 범위는?", a: "0.0.0.0 ~ 127.255.255.255 (단, 정확히 따지면 0.0.0.0는 특수목적이여서 쓸 수 없음.)" },
      { q: "B클래스의 IP 범위는?", a: "128.0.0.0 ~ 191.255.255.255" },
      { q: "C클래스의 IP 범위는?", a: "192.0.0.0 ~ 223.255.255.255" },
      { q: "D클래스의 IP 범위는?", a: "224.0.0.0 ~ 239.255.255.255" },
      { q: "E클래스의 IP 범위는?", a: "240.0.0.0 ~ 255.255.255.255" },
      { q: "A클래스의 사설 IP 범위는?", a: "10.0.0.0 ~ 10.255.255.255" },
      { q: "B클래스의 사설 IP 범위는?", a: "172.16.0.0 ~ 172.31.255.255" },
      { q: "C클래스의 사설 IP 범위는?", a: "192.168.0.0 ~ 192.168.255.255" },
      { q: "루프백(Loopback)의 주소 범위는? (IPv4 기준)", a: "127.0.0.0 ~ 127.255.255.255" },
      { q: "61.123.22.39의 네트워크 주소는?", a: "61.0.0.0" },
      { q: "201.31.65.87의 브로드캐스트 주소는?", a: "201.31.65.255" },
      { q: "송신자에서 수신자를 1명만 지정해서 데이터를 보내는 것은?", a: "유니캐스트" },
      { q: "같은 네트워크 안에 소속된 모든 장비에게 데이터를 보내는 것은?", a: "브로드캐스트" },
      { q: "특정 그룹에 속한 장비에게 데이터를 보내는 것은?", a: "멀티캐스트" },
      { q: "목적지 또는 출발지 IP 주소가 10.20.30.40 인 패킷만 선택하는 필터식은?", a: "ip.addr == 10.20.30.40" },
      { q: "브로드캐스트 프레임 수를 확인하는 필터식은?", a: "eth.dst == FF:FF:FF:FF:FF:FF" },
      { q: "ARP 프레임 중 브로드캐스트 프레임 수를 확인하는 필터식은?", a: "arp and eth.dst == FF:FF:FF:FF:FF:FF" },
      { q: "TCP의 SYN 세그먼트를 찾는 필터식은?", a: "tcp.flags.syn == 1" },
      { q: "목적지 포트 번호가 80번인 패킷을 찾는 필터식은?", a: "tcp.dstport == 80" },
      { q: "출발지 또는 목적지 IP 주소가 192.168.1.10 이고 출발지 또는 목적지 포트가 80번인 패킷을 찾는 필터식은?", a: "ip.addr == 192.168.1.10 and tcp.port == 80" },
      { q: "출발지 또는 목적지 IP 주소가 192.168.1.143 이고 출발지 또는 목적지 포트가 80번인 패킷을 찾는 필터식은?", a: "ip.addr == 192.168.1.143 and tcp.port == 80" },
      { q: "출발지 IP 주소가 192.168.1.10 에서 목적지 IP 주소가 192.168.1.143 으로 전달되는 패킷을 찾는 필터식은?", a: "ip.src == 192.168.1.10 and ip.dst == 192.168.1.143" },
      { q: "출발지 IP 주소가 192.168.1.10 에서 목적지 IP 주소가 192.168.1.143 으로 전달되는 TCP SYN 세그먼트를 찾는 필터식은?", a: "ip.src == 192.168.1.10 and ip.dst == 192.168.1.143 and tcp.flags.syn == 1" },
    ];

  let current = 0;
  let score = 0;
  const shuffled = quizData.sort(() => 0.5 - Math.random());
  let isAnswered = false;
  let isComposing = false;

  const questionEl = document.getElementById("question");
  const inputEl = document.getElementById("answerInput");
  const feedbackEl = document.getElementById("feedback");
  const summaryEl = document.getElementById("summary");

  function showQuestion() {
    isAnswered = false;
    feedbackEl.textContent = "";
    feedbackEl.style.color = "";
    inputEl.value = "";
    inputEl.disabled = false;
    inputEl.focus();

    if (current < shuffled.length) {
      questionEl.textContent = `${current + 1}. ${shuffled[current].q}`;
    } else {
      questionEl.textContent = "퀴즈 완료!";
      inputEl.style.display = "none";
      feedbackEl.style.display = "none";
      summaryEl.innerHTML = `총 ${shuffled.length}문제 중 <b>${score}개 정답</b>입니다.`;
    }
  }

  function checkAnswer() {
    const userInput = inputEl.value.trim();
    if (!userInput || isAnswered) return;

    isAnswered = true;
    const correctAnswer = shuffled[current].a.trim().toLowerCase();
    if (userInput.toLowerCase() === correctAnswer) {
      feedbackEl.textContent = "✅ 정답입니다!";
      feedbackEl.style.color = "green";
      score++;
    } else {
      feedbackEl.textContent = `❌ 오답입니다. 정답은: ${shuffled[current].a}`;
      feedbackEl.style.color = "red";
    }
  }

  function nextQuestion() {
    if (current < shuffled.length - 1) {
      current++;
      showQuestion();
    } else if (current === shuffled.length - 1) {
      current++;
      showQuestion();
    }
  }

  function prevQuestion() {
    if (current > 0) {
      current--;
      showQuestion();
    }
  }

  inputEl.addEventListener("compositionstart", () => {
  isComposing = true;
  });

  inputEl.addEventListener("compositionend", () => {
  isComposing = false;
  });

  inputEl.addEventListener("keydown", function (e) {
  if (e.key === "Enter" && !isComposing) {
    const userInput = inputEl.value.trim();

    if (!isAnswered) {
      if (!userInput) {
        feedbackEl.textContent = "정답을 입력해주세요.";
        feedbackEl.style.color = "gray";
      } else {
        checkAnswer();
      }
    } else {
      nextQuestion();
    }
  }
});

  showQuestion();
  </script>
</body>
</html>
